//
// automatically generated by spin2cpp v1.93 on Tue Aug 11 09:49:47 2015
// spin2cpp --ccode --main demo.spin 
//

// =================================================================================================
//
//   File....... jm_i2c.spin
//   Purpose.... Low-level I2C routines (requires pull-ups on SCL and SDA)
//   Author..... Jon "JonnyMac" McPhalen
//               Copyright (C) 2009-2015 Jon McPhalen
//               -- elements inspired by code from Mike Green
//   E-mail.....  
//   Started.... 28 JUL 2009
//   Updated.... 10 MAY 2015
//
// =================================================================================================
//  IMPORTANT Note: This code requires pull-ups on the SDA _and_ SCL lines -- it does not drive
//  the SCL line high.
#include <propeller.h>
#include "badgealpha.h"

#ifdef __GNUC__
#define INLINE__ static inline
#define Yield__() __asm__ volatile( "" ::: "memory" )
//define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#define Yield__()
#define waitcnt(n) _waitcnt(n)
#define coginit(id, code, par) _coginit((unsigned)(par)>>2, (unsigned)(code)>>2, id)
#define cognew(code, par) coginit(0x8, (code), (par))
#define cogstop(i) _cogstop(i)
#endif

INLINE__ int32_t Rotl__(uint32_t a, uint32_t b) { return (a<<b) | (a>>(32-b)); }
INLINE__ int32_t Rotr__(uint32_t a, uint32_t b) { return (a>>b) | (a<<(32-b)); }
int32_t jm_i2c_setup(jm_i2c *self)
{
  // Setup I2C using Propeller EEPROM pins
  jm_i2c_setupx(self, SCL1, SDA1);
  return 0;
}

int32_t jm_i2c_setupx(jm_i2c *self, int32_t sclpin, int32_t sdapin)
{
  int32_t _parm__0001[2];
  _parm__0001[0] = sclpin;
  _parm__0001[1] = sdapin;
  // Define I2C SCL (clock) and SDA (data) pins
  //  copy pins
  memmove( (void *)&self->scl, (void *)&_parm__0001[0], 4*(2));
  //  float to pull-up
  DIRA &= ~(1<<self->scl);
  //  write 0 to output reg
  OUTA &= ~(1<<self->scl);
  DIRA &= ~(1<<self->sda);
  OUTA &= ~(1<<self->sda);
  {
    int32_t _idx__0038;
    for(_idx__0038 = 0; _idx__0038 < 9; _idx__0038++) {
      // reset device
      DIRA |= (1<<self->scl);
      DIRA &= ~(1<<self->scl);
      if (((INA >> self->sda) & 0x1)) {
        break;
      }
    }
  }
  return 0;
}

int32_t jm_i2c_present(jm_i2c *self, int32_t ctrl)
{
  // Pings device, returns true it ACK
  jm_i2c_start(self);
  return -(jm_i2c_write(self, ctrl) == ACK);
}

int32_t jm_i2c_wait(jm_i2c *self, int32_t ctrl)
{
  int32_t	ackbit;
  // Waits for I2C device to be ready for new command
  do {
    jm_i2c_start(self);
    ackbit = jm_i2c_write(self, ctrl);
  } while (!(ackbit == ACK));
  return 0;
}

int32_t jm_i2c_start(jm_i2c *self)
{
  // Create I2C start sequence
  // -- will wait if I2C buss SDA pin is held low
  // float SDA (1)
  DIRA &= ~(1<<self->sda);
  // float SCL (1)
  DIRA &= ~(1<<self->scl);
  while (((INA >> self->scl) & 0x1) == 0) {
    Yield__();
  }
  // allow "clock stretching"
  // SDA low (0)
  DIRA |= (1<<self->sda);
  // SCL low (0)
  DIRA |= (1<<self->scl);
  return 0;
}

int32_t jm_i2c_write(jm_i2c *self, int32_t i2cbyte)
{
  int32_t	ackbit;
  // Write byte to I2C buss                                         
  // -- leaves SCL low                                              
  // move msb (bit7) to bit31
  i2cbyte = (i2cbyte ^ 0xff) << 24;
  {
    int32_t _idx__0039;
    for(_idx__0039 = 0; _idx__0039 < 8; _idx__0039++) {
      // output eight bits
      // send msb first
      DIRA = ((DIRA & (~(1 << self->sda))) | (((i2cbyte = Rotl__(i2cbyte, 1)) & 0x1) << self->sda));
      // SCL high (float to p/u)
      DIRA &= ~(1<<self->scl);
      // SCL low
      DIRA |= (1<<self->scl);
    }
  }
  // relase SDA to read ack bit
  DIRA &= ~(1<<self->sda);
  // SCL high (float to p/u)  
  DIRA &= ~(1<<self->scl);
  // read ack bit
  ackbit = ((INA >> self->sda) & 0x1);
  // SCL low
  DIRA |= (1<<self->scl);
  return ackbit;
}

int32_t jm_i2c_read(jm_i2c *self, int32_t ackbit)
{
  int32_t	i2cbyte;
  // Read byte from I2C buss
  // make sda input
  DIRA &= ~(1<<self->sda);
  {
    int32_t _idx__0040;
    for(_idx__0040 = 0; _idx__0040 < 8; _idx__0040++) {
      // SCL high (float to p/u)
      DIRA &= ~(1<<self->scl);
      // read the bit
      i2cbyte = (i2cbyte << 1) | ((INA >> self->sda) & 0x1);
      // SCL low
      DIRA |= (1<<self->scl);
    }
  }
  // output ack bit 
  DIRA = ((DIRA & (~(1 << self->sda))) | (((~ackbit) & 0x1) << self->sda));
  // clock it
  DIRA &= ~(1<<self->scl);
  DIRA |= (1<<self->scl);
  return (i2cbyte & 0xff);
}

int32_t jm_i2c_stop(jm_i2c *self)
{
  // Create I2C stop sequence 
  // SDA low
  DIRA |= (1<<self->sda);
  // float SCL
  DIRA &= ~(1<<self->scl);
  do {
    Yield__();
  } while (!(((INA >> self->scl) & 0x1) == 1));
  // hold for clock stretch
  // float SDA
  DIRA &= ~(1<<self->sda);
  return 0;
}

/* 

  Copyright (C) 2009-2015 Jon McPhalen

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

 */
