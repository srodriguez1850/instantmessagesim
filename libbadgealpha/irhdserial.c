//
// automatically generated by spin2cpp v1.93 on Sun Aug 16 16:35:52 2015
// spin2cpp --ccode --main IrApp.spin 
//

//   MMA7660 accelerometer
// =================================================================================================
//
//   File....... jm_ir_hdserial.spin
//   Purpose.... Half-duplex, true-mode serial IO or IR
//   Author..... Jon "JonnyMac" McPhalen 
//               Copyright (c) 2009-2015 Jon McPhalen
//               -- see below for terms of use
//   E-mail..... jon@jonmcphalen.com
//   Started.... 
//   Updated.... 28 JUL 15
//
// =================================================================================================
/* 

    Example IR Connections
 
              ┌───┐
              │(*)│ 3.3-5v (device dependent)
              └┬┬┬┘ 
         rx ──┘│└──┘
                


              IR
      3.3v ──────┐
                    │
        tx ──────┘
               33


              33  IR
        tx ───────┐
                            

 */
#include <stdlib.h>
#include <propeller.h>
#include "badgealpha.h"

#ifdef __GNUC__
#define INLINE__ static inline
#define Yield__() __asm__ volatile( "" ::: "memory" )
//define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#define Yield__()
#define waitcnt(n) _waitcnt(n)
#define coginit(id, code, par) _coginit((unsigned)(par)>>2, (unsigned)(code)>>2, id)
#define cognew(code, par) coginit(0x8, (code), (par))
#define cogstop(i) _cogstop(i)
#endif

INLINE__ int32_t Rotl__(uint32_t a, uint32_t b) { return (a<<b) | (a>>(32-b)); }
INLINE__ int32_t Rotr__(uint32_t a, uint32_t b) { return (a>>b) | (a<<(32-b)); }
INLINE__ int32_t Lookup__(int32_t x, int32_t b, int32_t a[], int32_t n) { int32_t i = (x)-(b); return ((unsigned)i >= n) ? 0 : (a)[i]; }

static uint8_t dat[] = {
  0xf0, 0xb1, 0xbc, 0xa0, 0x58, 0x90, 0xbc, 0xa0, 0x04, 0xb0, 0xfc, 0x80, 0x58, 0x92, 0xbc, 0xa0, 
  0x04, 0xb0, 0xfc, 0x80, 0x58, 0x94, 0xbc, 0x08, 0x04, 0xb0, 0xfc, 0x80, 0x58, 0x96, 0xbc, 0xa0, 
  0x04, 0xb0, 0xfc, 0x80, 0x58, 0x98, 0xbc, 0xa0, 0x04, 0xb0, 0xfc, 0x80, 0x58, 0x9a, 0xbc, 0x08, 
  0x04, 0xb0, 0xfc, 0x80, 0x58, 0xb2, 0xbc, 0x08, 0x01, 0x9c, 0xfc, 0xa0, 0x59, 0x9c, 0xbc, 0x2c, 
  0x4e, 0xec, 0xbf, 0x64, 0x04, 0xb0, 0xfc, 0x80, 0x58, 0xb2, 0xbc, 0x08, 0x01, 0x9e, 0xfc, 0xa0, 
  0x59, 0x9e, 0xbc, 0x2c, 0x4f, 0xec, 0xbf, 0x64, 0x04, 0xb0, 0xfc, 0x80, 0x58, 0xa0, 0xbc, 0x08, 
  0x50, 0xa2, 0xbc, 0xa0, 0x01, 0xa2, 0xfc, 0x28, 0x50, 0xa2, 0xbc, 0x80, 0x04, 0xb0, 0xfc, 0x80, 
  0x58, 0xf4, 0xbf, 0x08, 0x46, 0xb2, 0xbc, 0x68, 0x59, 0xf0, 0xbf, 0xa0, 0xf1, 0xa9, 0xbc, 0xa0, 
  0xf2, 0x9d, 0x3c, 0x61, 0x32, 0x00, 0x70, 0x5c, 0x51, 0xa8, 0xbc, 0x80, 0x00, 0xa4, 0xfc, 0xa0, 
  0x08, 0xa6, 0xfc, 0xa0, 0x50, 0xa8, 0xbc, 0xf8, 0xf2, 0x9d, 0x3c, 0x61, 0x01, 0xa4, 0xfc, 0x28, 
  0x80, 0xa4, 0xfc, 0x70, 0x25, 0xa6, 0xfc, 0xe4, 0x4e, 0x9c, 0x3c, 0xf0, 0x48, 0xb0, 0xbc, 0x08, 
  0x4a, 0xb0, 0xbc, 0x80, 0x58, 0xa4, 0x3c, 0x00, 0x4a, 0xb0, 0xbc, 0x84, 0x01, 0xb0, 0xfc, 0x80, 
  0x7f, 0xb0, 0xfc, 0x60, 0x48, 0xb0, 0x3c, 0x08, 0x4b, 0xb0, 0xbc, 0x08, 0x4c, 0xb2, 0xbc, 0x08, 
  0x59, 0xb0, 0x3c, 0x86, 0x1f, 0x00, 0x68, 0x5c, 0x4d, 0xb0, 0xbc, 0xa0, 0x59, 0xb0, 0xbc, 0x80, 
  0x58, 0xaa, 0xbc, 0x00, 0x01, 0xb2, 0xfc, 0x80, 0x7f, 0xb2, 0xfc, 0x60, 0x4c, 0xb2, 0x3c, 0x08, 
  0x47, 0xaa, 0xbc, 0x68, 0x01, 0xaa, 0xfc, 0x2c, 0x0b, 0xac, 0xfc, 0xa0, 0x50, 0xae, 0xbc, 0xa0, 
  0xf1, 0xaf, 0xbc, 0x80, 0x01, 0xaa, 0xfc, 0x29, 0x4f, 0xec, 0xbf, 0x74, 0x50, 0xae, 0xbc, 0xf8, 
  0x41, 0xac, 0xfc, 0xe4, 0x32, 0x00, 0x7c, 0x5c, 0x00, 0x00, 0x00, 0x10, 0x00, 0xff, 0xff, 0xff, 
};

jm_ir_hdserial hdserial;
jm_ir_hdserial *self;

int32_t ircom_start(int32_t rxd, int32_t txd, int32_t baud, int32_t freq)
{
  self = &hdserial;
  
  int32_t _parm__0009[4];
  _parm__0009[0] = rxd;
  _parm__0009[1] = txd;
  _parm__0009[2] = baud;
  _parm__0009[3] = freq;
  // Half-duplex, true mode UART 
  // -- rxd is rx pin (in)
  // -- txd is tx pin (out)
  // -- baud is baud rate for coms (2400 suggested)
  // -- freq is IR modulation frequency (e.g., 38000)
  // stop UART driver
  ircom_stop();
  // clear (for restart)
  memset( (void *)&self->rxhead, 0, sizeof(int32_t)*6);
  // provide buffer locations                                              
  self->rxhub = (int32_t)(&self->rxbuf[0]);
  self->txhub = (int32_t)(&self->txbuf[0]);
  // copy pins
  memmove( (void *)&self->rxpin, (void *)&_parm__0009[0], 4*(2));
  // set bit time for baud rate
  self->bitticks = CLKFREQ / _parm__0009[2];
  // modulation setup              
  self->frsetup = ((int32_t)0x80000000U / (CLKFREQ / _parm__0009[3])) << 1;
  // disable pins in calling cog
  DIRA &= ~(1<<_parm__0009[0]);
  DIRA &= ~(1<<_parm__0009[1]);
  // start UART cog
  self->cog = cognew((int32_t)(&(*(int32_t *)&dat[0])), (int32_t)(&self->rxhead)) + 1;
  return self->cog;
}

void ircom_stop(void)
{
  // Stops IR UART cog
  if (self->cog) {
    cogstop((self->cog - 1));
    self->cog = 0;
  }
  //return 0;
}

/*  ---------------------  */
/*   R X   M E T H O D S   */
/*  ---------------------  */
int32_t ircom_rx(void)
{
  int32_t	c;
  // Pulls c from receive buffer if available
  // -- will wait if buffer is empty
  while (self->rxtail == self->rxhead) {
    Yield__();
  }
  c = self->rxbuf[self->rxtail];
  self->rxtail = (++self->rxtail) & BUF_MASK;
  return c;
}

int32_t ircom_rxcheck(void)
{
  int32_t	c;
  // Pulls c from receive buffer if available
  // -- returns -1 if buffer is empty
  c = -1;
  if (self->rxtail != self->rxhead) {
    // something in buffer?
    // get it
    c = self->rxbuf[self->rxtail];
    // update tail pointer
    self->rxtail = (++self->rxtail) & BUF_MASK;
  }
  return c;
}

int32_t ircom_rxtime(int32_t ms)
{
  int32_t	t, c;
  // Wait ms milliseconds for a byte to be received
  // -- returns -1 if no byte received, $00..$FF if byte
  t = CNT;
  while (!(((c = ircom_rxcheck()) >= 0) || (((CNT - t) / (CLKFREQ / 1000)) > ms))) {
    Yield__();
  }
  return c;
}

int32_t ircom_rxflush(void)
{
  // Flush receive buffer
  while (ircom_rxcheck() >= 0) {
    Yield__();
  }
  return 0;
}

/*  ---------------------  */
/*   T X   M E T H O D S   */
/*  ---------------------  */
int32_t ircom_tx(int32_t c)
{
  // Move c into transmit buffer if room is available
  // -- will wait if buffer is full
  while (!(self->txtail != ((self->txhead + 1) & BUF_MASK))) {
    Yield__();
  }
  self->txbuf[self->txhead] = c;
  self->txhead = (++self->txhead) & BUF_MASK;
  return 0;
}

int32_t ircom_str(char *p_zstr)
{
  // Transmit z-string at pntr
  {
    int32_t _idx__0045;
    int32_t _limit__0046 = strlen((char *) p_zstr);
    for(_idx__0045 = 0; _idx__0045 < _limit__0046; _idx__0045++) {
      ircom_tx(((uint8_t *)(p_zstr++))[0]);
    }
  }
  return 0;
}

int32_t ircom_dec(int32_t value)
{
  int32_t	i, x;
  int32_t result = 0;
  // Transmit a value in decimal format              
  // mark max negative
  x = -(value == (int32_t)0x80000000U);
  if (value < 0) {
    // if negative                   
    // make positive and adjust
    value = abs((value + x));
    // print sign
    ircom_tx('-');
  }
  // set divisor
  i = 1000000000;
  {
    int32_t _idx__0047;
    for(_idx__0047 = 0; _idx__0047 < 10; _idx__0047++) {
      if (value >= i) {
        // non-zero digit for this divisor?                  
        //  print digit                    
        ircom_tx((((value / i) + '0') + (x * -(i == 1))));
        //  remove from value
        value = value % i;
        //  set printing flag                      
        result = -1;
      } else {
        if ((result) || (i == 1)) {
          // if printing or last digit            
          //  print zero
          ircom_tx('0');
        }
      }
      // update divisor
      i = i / 10;
    }
  }
  return result;
}

int32_t ircom_rjdec(int32_t val, int32_t width, int32_t pchar)
{
  int32_t	tmpval, pad;
  // Transmit right-justified decimal value
  // -- val is value to print
  // -- width is width of (pchar padded) field for value
  //  Original code by Dave Hein
  //  Modified by Jon McPhalen
  if (val >= 0) {
    // if positive
    //  copy value
    tmpval = val;
    //  make room for 1 digit
    pad = width - 1;
  } else {
    if (val == (int32_t)0x80000000U) {
      //  if max negative
      //    use max positive for width
      tmpval = 2147483647;
    } else {
      //  else
      //    make positive
      tmpval = -val;
    }
    //  make room for sign and 1 digit
    pad = width - 2;
  }
  while (tmpval >= 10) {
    // adjust pad for value width > 1
    (pad--);
    tmpval = tmpval / 10;
  }
  {
    int32_t _idx__0048;
    int32_t _limit__0049 = pad;
    for(_idx__0048 = 0; _idx__0048 < _limit__0049; _idx__0048++) {
      // transmit pad
      ircom_tx(pchar);
    }
  }
  // trasnmit value
  ircom_dec(val);
  return 0;
}

int32_t ircom_hex(int32_t value, int32_t digits)
{
  static int32_t look__0050[] = {48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, };

  // Transmit a value in hexadecimal format              
  value = value << ((8 - digits) << 2);
  {
    int32_t _idx__0051;
    int32_t _limit__0052 = digits;
    for(_idx__0051 = 0; _idx__0051 < _limit__0052; _idx__0051++) {
      ircom_tx(Lookup__(((value = Rotl__(value, 4)) & 0xf), 0, look__0050, 16));
    }
  }
  return 0;
}

int32_t ircom_tx_bin(int32_t value, int32_t digits)
{
  // Transmit a value in binary format              
  value = value << (32 - digits);
  {
    int32_t _idx__0053;
    int32_t _limit__0054 = digits;
    for(_idx__0053 = 0; _idx__0053 < _limit__0054; _idx__0053++) {
      ircom_tx((((value = Rotl__(value, 1)) & 0x1) + '0'));
    }
  }
  return 0;
}

int32_t ircom_txflush(void)
{
  // Wait for transmit buffer to empty, then wait for byte to transmit
  while (!(self->txtail == self->txhead)) {
    Yield__();
  }
  {
    int32_t _idx__0055;
    for(_idx__0055 = 0; _idx__0055 < 11; _idx__0055++) {
      // start + 8 + 2
      waitcnt((self->bitticks + CNT));
    }
  }
  return 0;
}

/* 

  Copyright (C) 2009-2015 Jon McPhalen

  Terms of Use: MIT License 

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

 */
